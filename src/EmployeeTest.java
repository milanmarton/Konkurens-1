import java.util.ArrayList;
import java.util.List;

public class EmployeeTest {
    public static void main(String[] args) {
        // create manager
        Manager manager = new Manager("Gregorics Tibor", 100000.0f);

        // create subordinates
        Subordinate sub1 = new Subordinate("Sanyi", 50000.0f);
        Subordinate sub2 = new Subordinate("Adorjan", 60000.0f);

        // create subcontractor
        Subcontractor subcontractor = new Subcontractor(123456789L, 75000.0f);

        // add subordinates to manager
        manager.addEmployee(sub1);
        manager.addEmployee(sub2);

        System.out.println("Manager: " + manager.getName() + ", Salary: " + manager.getSalary() + " Ft");
        System.out.println("Subordinate 1: " + sub1.getName() + ", Salary: " + sub1.getSalary() + " Ft");
        System.out.println("Subordinate 2: " + sub2.getName() + ", Salary: " + sub2.getSalary() + " Ft");

        // remove a subordinate
        manager.removeEmployee(sub2);

        System.out.println("\nAfter removing a subordinate:");
        System.out.println("Manager: " + manager.getName() + ", Salary: " + manager.getSalary() + " Ft");


        System.out.println("Subcontractor tax number: " + subcontractor.getTaxNumber() + ", Salary: "
        + subcontractor.getSalary() + " Ft");

    }
}


// interface
interface SalariedEntity {
    float getSalary();
}

// implements is the keyword for classes that implement an interface
abstract class Employee implements SalariedEntity {
    private String name;
    // private -> protected (to be able to access it from subclasses)
    protected float salary;

    // you can generate the constructor and the getters with intelliJ
    public Employee(String n, float s) {
        name = n;
        salary = s;
    }

    public String getName() {
        return name;
    }

    // abstract method
    public abstract float getSalary();

    public void raiseSalary(float percent) {
        salary = salary + (salary * percent);
    }
}

// extends is the keyword for inheritance
class Subordinate extends Employee {

    // can be generated by intellij
    public Subordinate(String n, float s) {
        /* super to use the parent's
        constructor just like in python */
        super(n, s);
    }

    // override can be generated by intellij
    @Override
    public float getSalary() {
        return salary;
    }
}

class Manager extends Employee {
    private List<Employee> subordinates; // needs java.util.List but intellij imports it with 'List' + tab

    public Manager(String n, float s) {
        super(n, s);
        /* List is only an abstract concept we need a specific list implementation we can use
        (ArrayList is dynamic so it's good here) */
        this.subordinates = new ArrayList<>(); // needs java.util.ArrayList but intellij imports it with 'Array' + tab
    }

    public void addEmployee(Employee employee) {
        subordinates.add(employee);
    }

    public void removeEmployee(Employee employee) {
        subordinates.remove(employee);
    }

    @Override
    public float getSalary() {
        float totalSubordinateSalary = 0;
        // sum of all subordinates' salaries
        for (Employee emp : subordinates) {
            totalSubordinateSalary += emp.getSalary();
        }

        return salary + (0.05f * totalSubordinateSalary);
    }
}

class Subcontractor implements SalariedEntity {
    private long taxNumber;
    private float salary;


    public Subcontractor(long taxNumber, float salary) {
        // 'this' keyword
        this.taxNumber = taxNumber;
        this.salary = salary;
    }

    public long getTaxNumber() {
        return taxNumber;
    }

    @Override
    public float getSalary() {
        return salary;
    }   
}