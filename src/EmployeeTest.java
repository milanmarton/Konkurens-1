import java.util.ArrayList;
import java.util.List;

public class EmployeeTest {
    public static void main(String[] args) {
        // create company
        Company company = new Company();

        // create manager
        Manager manager = new Manager("Gregorics Tibor", 100000.0f);

        // create subordinates
        Subordinate sub1 = new Subordinate("Sanyi", 50000.0f);
        Subordinate sub2 = new Subordinate("Adorjan", 60000.0f);

        // create subcontractor
        Subcontractor subcontractor = new Subcontractor(123456789L, 75000.0f);

        // add subordinates to manager
        manager.addEmployee(sub1);
        manager.addEmployee(sub2);

        // add everyone to the company
        company.addSalariedEntity(manager);
        company.addSalariedEntity(sub1);
        company.addSalariedEntity(sub2);
        company.addSalariedEntity(subcontractor);

        // print initial salaries
        System.out.println("Initial salaries:");
        printSalaries(company);

        // raise employee salaries by 15%
        company.raiseEmployeeSalaries(0.15f);

        // after raise salaries
        System.out.println("Raised salaries:");
        printSalaries(company);

        // remove subordinate
        company.removeSalariedEntity(sub2);
        manager.removeEmployee(sub2);

        // after removal
        System.out.println("Salaries after removal:");
        printSalaries(company);


    }

    private static void printSalaries(Company company) {
        for (SalariedEntity entity : company.getSalariedEntities()) {
            if (entity instanceof Employee) {
                Employee emp = (Employee) entity; // (Employee) is needed
                System.out.println(emp.getName() + ": " + emp.getSalary() + " Ft");
            } else if (entity instanceof Subcontractor) {
                Subcontractor sub = (Subcontractor) entity;
                System.out.println("Subcontractor (Tax Number: " + sub.getTaxNumber() + "): " + sub.getSalary() + " Ft");
            }
        }
    }
}


// interface
interface SalariedEntity {
    float getSalary();
}

// implements is the keyword for classes that implement an interface
abstract class Employee implements SalariedEntity {
    private String name;
    // private -> protected (to be able to access it from subclasses)
    protected float salary;

    // you can generate the constructor and the getters with intelliJ
    public Employee(String n, float s) {
        name = n;
        salary = s;
    }

    public String getName() {
        return name;
    }

    // abstract method
    public abstract float getSalary();

    public void raiseSalary(float percent) {
        salary = salary + (salary * percent);
    }
}

// extends is the keyword for inheritance
class Subordinate extends Employee {

    // can be generated by intellij
    public Subordinate(String n, float s) {
        /* super to use the parent's
        constructor just like in python */
        super(n, s);
    }

    // override can be generated by intellij
    @Override
    public float getSalary() {
        return salary;
    }
}

class Manager extends Employee {
    private List<Employee> subordinates; // needs java.util.List but intellij imports it with 'List' + tab

    public Manager(String n, float s) {
        super(n, s);
        /* List is only an abstract concept we need a specific list implementation we can use
        (ArrayList is dynamic so it's good here) */
        this.subordinates = new ArrayList<>(); // needs java.util.ArrayList but intellij imports it with 'Array' + tab
    }

    public void addEmployee(Employee employee) {
        subordinates.add(employee);
    }

    public void removeEmployee(Employee employee) {
        subordinates.remove(employee);
    }

    @Override
    public float getSalary() {
        float totalSubordinateSalary = 0;
        // sum of all subordinates' salaries
        for (Employee emp : subordinates) {
            totalSubordinateSalary += emp.getSalary();
        }

        return salary + (0.05f * totalSubordinateSalary);
    }
}

class Subcontractor implements SalariedEntity {
    private long taxNumber;
    private float salary;


    public Subcontractor(long taxNumber, float salary) {
        // 'this' keyword
        this.taxNumber = taxNumber;
        this.salary = salary;
    }

    public long getTaxNumber() {
        return taxNumber;
    }

    @Override
    public float getSalary() {
        return salary;
    }
}

class Company {
    private List<SalariedEntity> salariedEntities;

    // empty arraylist
    public Company() {
        this.salariedEntities = new ArrayList<>();
    }

    public void addSalariedEntity(SalariedEntity entity) {
        salariedEntities.add(entity);
    }

    public void removeSalariedEntity(SalariedEntity entity) {
        // this doesn't remove a subordinate from a manager
        salariedEntities.remove(entity);
    }

    public void raiseEmployeeSalaries(float percent) {
        for (SalariedEntity entity : salariedEntities) {
            // instanceof operator in Java is used to check the type of an object at runtime
            if (entity instanceof Employee) {
                ((Employee) entity).raiseSalary(percent); // entity.raise + tab formatted it this way,
                // I have no idea about this syntax xd
            }
        }
    }

    public List<SalariedEntity> getSalariedEntities() {
        // it needs to be new (?)
        return new ArrayList<>(salariedEntities);
    }
}